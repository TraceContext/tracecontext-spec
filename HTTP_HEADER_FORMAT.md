# Trace Context HTTP Header Format

A trace context header is used to pass trace context information across systems
for a HTTP request. Our goal is to share this with the community so that various
tracing and diagnostics products can operate together, and so that services can
pass context through them, even if they're not being traced (useful for load
balancers, etc.)

# Format

## Header name

`Trace-Context` is the name of the [Http header field](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields) being defined here. 

## Field value

The format of the value a list of data values, each value is identified by a 
unique prefix character the defines the meaning of the value as well as its
format.  

values of a particular kind need not necessarily be present, but they must be 
in the order defined below (e.g. if the Trace-id is present it must be first)

The prefix values currently defined are

### Prefix '*' The Trace-id 

The '*' character indicates that the next 32 characters are hexadecimal digits (lower case)
that represent a 16 byte identifier.  This identifier is meant to uniquely identify 
new 'trace'.   The intent is that all requests that are caused directly or 
indirection from this initial request will share this Trace-id.  It is expected that
this identifier will be generated by selecting a 16byte random number.   

Example
```
	*4bf92f3577b34da6a3ce929d0e0e4736
```

### Prefix '-' The Span-id 

The '-' prefix indicates that the next 16 characters are hexadecimal digits (lower case)
that represent an 8 byte identifier.   This identifier is meant to , in combination with 
the Trace-id, uniquely identify the request being serviced.   

Example
```
	-00f067aa0ba902b7
```

### Prefix '~' The Trace Recommendation Flag

The '~' prefix is not followed by any additional characters.   If present, it provides
a recommendation whether the request should be traced or not.   If present, the
caller recommends that the request should be traced, otherwise caller does not make a decision to trace
and the decision might be deferred). The flags are recommendations given by the
caller rather than strict rules to follow for 3 reasons:

1.  Trust and abuse.
2.  Bug in caller
3.  Different load between caller service and callee service might force callee
    to down sample.

### Prefix '.' The Hierarchical-id

The '.' character indicates that a variable number of characters follow and represent
a hierarchical (path based) id.   It has the form of a list of hexadecimal numbers 
(lower case) separated by '.' characters.   The list is optionally terminated by 
a '!' character.   The id ends if either the string ends or a character that 
is not a hexadecimal character or a '.' or '!' is encountered.   

Examples

```
	.1
	.3.b.34.ca25.56
	.334.ba34.93a4.1.1!
```
The hierarchical ID is meant to represent series of causal requests within the scope
of a given Trace-id.   Take has a whole, like the Span-ID, combined with the Trace-id
it uniquely identifies the request.    However in addition the components also represent
other requests with that same trace that are causality connects.  For example the Trace-Context
value of 
```
*4bf92f3577b34da6a3ce929d0e0e4736.3.b.34
```
Represents a request with ID
```
*4bf92f3577b34da6a3ce929d0e0e4736.3.b.34
```
that was caused by a request with ID
```
*4bf92f3577b34da6a3ce929d0e0e4736.3.b
```
which in turn was caused by request with 
```
*4bf92f3577b34da6a3ce929d0e0e4736.3
```
Hierarchical ID are conceptually unbounded in length, but as a practical matter must be
limited, if only to avoid issues when infinite request loops form.   The '!' character 
is meant to indicate the ID has been truncated.  The ID as a whole should still be unique
within the Trace-id, but the fine grained causality information will not be present.   

### Examples of HTTP headers

Note that not all the allowed value prefixes are expected to be used simultaneously.  __In particular it is expected that only one of the Span-id or Hierarchical-id will be used.__

It is however expected that the Trace-id will always be present.  

Parsers are free to reject any prefixes they do not wish to support, but implementations
are encouraged to support in some way any prefixes they can do something useful with, and
to simply ignore things that they don't understand.   This maximizes interoperability.  

Example 1
```
Trace-context:*4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7~
```
This represents 
```
base16(<Trace-id>) = 4bf92f3577b34da6a3ce929d0e0e4736
base16(<Span-id>) = 00f067aa0ba902b7
<TraceRecommendation> = true
```

Example 2
```
Trace-context:*4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7
```
This represents 
```
base16(<Trace-id>) = 4bf92f3577b34da6a3ce929d0e0e4736
base16(<Span-id>) = 00f067aa0ba902b7
<TraceRecommendation> = false
```

Example 3
```
Trace-context:*4bf92f3577b34da6a3ce929d0e0e.4736.34.22.23~
```
This represents 
```
base16(<Trace-id>) = 4bf92f3577b34da6a3ce929d0e0e
base16(<Hierarchicial-id>) = 4736.34.22.23
<TraceRecommendation> = true
```

# Versioning

There is no version number in the Trace-Context field.  The intent is that new prefixes will 
be defined if changes are needed.   These new prefixes would be put at the end of the id
and existing parsers would encounter them and give up, ignoring the data.   Thus existing
parsers will parse what they can (most critically the Trace-id) to maximize interoperability.

In the case that the parser encounters prefixes that it does not understand, or other syntax
errors, ideally the logging system would original text of the Trace-Context field, so that the
back end of the logging system has all the information possible with which to reconstruct 
the causality of the requests.   
