# Trace Context HTTP Header Format

A trace context header is used to pass trace context information across systems
for a HTTP request. Our goal is to share this with the community so that various
tracing and diagnostics products can operate together, and so that services can
pass context through them, even if they're not being traced (useful for load
balancers, etc.)

# Format

## Header Header name

`Trace-Context` is the name of the [Http header field](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields) being defined here. 

## HTTP Header Field value

The format of the value of hte `trace-Context` header is a string represneting
a list of tagged values.  Each value has a defined prefix (tag) character that
allows parsers to determine that value is present.   

From a syntatic point of view,  any particular value need not necessarily be present,
but if they are present they must be in the order defined below (e.g. if the Trace-id is present it must be first).

The data values currently defined are

### Trace-id Value (Tag '*') 

The '*' character indicates that the next 32 characters are hexadecimal digits (lower case)
that represent a 16 byte identifier.  This identifier is meant to uniquely identify 
new 'trace'.   The intent is that all requests that are caused directly or 
indirectly from this initial request will share this Trace-id.  It is expected that
this identifier will be generated by selecting a 16 byte random number.   

Example
```
	*4bf92f3577b34da6a3ce929d0e0e4736
```

### The Span-id (Tag '-')

The '-' tag indicates that the next 16 characters are hexadecimal digits (lower case)
that represent an 8 byte identifier.   This identifier is meant to , *in combination with*
the Trace-id, uniquely identify the request.      

Example
```
	-00f067aa0ba902b7
```

### Options (Tag '~') 

The '~' tag is followed by one or two hexadecimal digits (lower case).   Any non-hexidecimal
digits terminate the options value.    These two digits represent 1 byte (up to 8) boolan options.  

If this options value is not present the bits are assumed to be 0 (false)

Currently the bits of this byte are defined as follows (Currently only 1 bit is defined)

#### Trace Recomendation bit (Options Bit 0 (value 0x1))

If set, this bit provides a recommendation whether the request should be traced or not.   If present, the
caller recommends that the request should be traced, otherwise caller does not make a decision to trace
and the decision might be deferred). The flags are recommendations given by the
caller rather than strict rules to follow for 3 reasons:

1.  Trust and abuse.
2.  Bug in caller
3.  Different load between caller service and callee service might force callee
    to down sample.

### Expected Behavior of parsers to unknown tags.  

The intent of this standard is to ALLOW interoperablity among logging systems.   A logging system
is free to ignore any 'Trace-Contect' field value that it does not understand.  However this leads to 
the poorest interoperability with other logging systems and generally negates the value of this
specification.    

At a miniumum logging system are strongly encouraged to parse any tagged values that they
DO understand.  In particular the main value of doing this is that logging systems that share
the concept of a Trace-id (which seem to be all of them), can at least find the collection of all
events from ALL logging systems that coorespond to a paritcular top-level request.  

In addition, to the degree possible, logging system are encouraged to not destroy information they
find in the 'Trace-Context' field.   Ideally any data that could not be parsed would be logged along
with any ID that the logging system assigns to the requests.   

More interoperability can be achived, but becomes context sensitive andis covered elswhere.  

# Complete Examples of HTTP headers 

Here are complete examples of HTTP headers that obey this syntax.   

Example 1
```
Trace-context:*4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7~1
```
This represents 
```
base16(<Trace-id>) = 4bf92f3577b34da6a3ce929d0e0e4736
base16(<Span-id>) = 00f067aa0ba902b7
<TraceRecommendation> = true
```

Example 2
```
Trace-context:*4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7~0
```
The options value is 0 so bit 1 is false, so it represents represents 
```
base16(<Trace-id>) = 4bf92f3577b34da6a3ce929d0e0e4736
base16(<Span-id>) = 00f067aa0ba902b7
<TraceRecommendation> = false

```

Example 3
```
Trace-context:*4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7
```
Because the options tag is not present, this also represents an options value of 0 so this represents
```
base16(<Trace-id>) = 4bf92f3577b34da6a3ce929d0e0e4736
base16(<Span-id>) = 00f067aa0ba902b7
<TraceRecommendation> = false
```

# Versioning

The primary goal of this format is to be SIMPLE and to provide FLEXIBILITY for different logging
systems to SHARE WHAT THEY CAN, but to ENCODE what is different.    It also allows for
the format to evolve over time WITHOUT having to update all the parsers first.  New tags will 
be defined if changes are needed.   These new tags would be put at the end of the id
and existing parsers would encounter them and give up, ignoring the data.   Thus existing
parsers will parse what they can (most critically the Trace-id) to maximize interoperability.


#Structured Span IDs

The specification above gives only one way of specifying the Span-id and requires it to
be of a very particular format.    To allow for systems that desire this ID to have structure
(and more importantly here, variable size) we used the flexibility of the tagging system to
define a mechanism for these systems to encode this information.  See [STRUCTURED_IDS.md](./STRUCTURED_IDS.md) for more.  
Systems that do not care about interop between these logging systems can ignore this case.   
